package ptbm.models

import ptbm.VariationalReal
import org.apache.commons.math3.distribution.NormalDistribution
import bayonet.math.NumericalUtils

model Tawn2022 {
  
  param Integer dim ?: 20
  random List<RealVar> xs ?: latentRealList(dim)
  
  param Double box ?: 20.0
    
  
  laws {
    
    for (RealVar x : xs) {
      
      x | box  ~ ContinuousUniform(-box - 3.0, box + 3.0)
      
    }
    
    | box, dim, xs, NormalDistribution n = new NormalDistribution() ~ LogPotential({
      var logSum = NEGATIVE_INFINITY
      for (k : 1..4) {
        var sum = 0.0
        
        for (j : 1 .. dim) {
          val wk = if (k <= 2) 1.0 else 2.0
          sum += log(2.0) - log(wk)
          
          val muk = 
            if      (k == 1) box
            else if (k == 2) -box
            else if (k == 3 && j <= dim/2) -box/2.0
            else if (k == 3 && j > dim/2) box/2.0
            else if (k == 4 && j <= dim/2) box/2.0
            else -box/2.0;
            
          val xj = xs.get(j-1).doubleValue
            
          sum += n.logDensity((xj - muk) / wk)
          sum += log(n.cumulativeProbability(10.0 * (xj - muk) / wk))
        }
        
        logSum = NumericalUtils.logAdd(logSum, sum)
      }
      return logSum
    })
    
  }
}